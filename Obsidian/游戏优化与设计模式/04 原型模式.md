
### 零、概念

- 一种创建型设计模式，是创建型中唯一不依赖构造函数的方式

- 使开发者可以复制已有对象，而又无需代码依赖它们所属的类

- 适合对象结构相似但状态不同的场景

### 一、实现要点

- 先定义克隆方法（`clone()`），C#中可以实现`ICloneable`接口

- 克隆时的拷贝方式选择
	
	- **浅拷贝**：不复制不可变的、占用内存大的对象（如纹理），而只提供引用，运行时保证不会修改
	
	- **深拷贝**：完全复制运行时可能需要修改的字段

- 克隆后的对象应当是不共享、独立的


### 二、UML图演示

![500](原型模式UML.png)

### 三、具体应用

#### 游戏中的武器类：

- 目前设计的UML图：

![500](原型模式例1.png)

- **有两大问题**：

	- `attack(Spell*)`函数不规范，需显式保证其在调用时一定执行，否则会造成`Spell`被创建但未使用的性能浪费
	
		- 如果有限制，就不应存在于公有域中，不符合软件开发规范
	
	- 添加新武器无法复用代码，需要继承类并重写武器类的所有函数
	
		- 但实际上武器之间只有“子弹”（`Spell`特效）和“板机”（触发的按键/事件）的不同，替换这二者即可
		
		- 其他的函数（如初始化函数`init()`）以及冷却属性等成员变量完全可以复用

- 重构后的武器类：

![500](原型模式例2.png)

- `spell_prototype_`和 `trigger_`可以视为两个组件

- 添加新武器时，通过`setSpellPrototype()`和`setTrigger()`给其设置新的`spell`和`trigger`即可

- 同时，`Weapon`的`Spell`不再依赖外部创建和传入，而是自己持有成员变量`spell _prototype_`

	- 并在`Spell`类中添加`clone()`方法，攻击时复制到场景中
	
	- 这样，特效生成就从属于`attack()`的执行，防止特效生成但攻击没执行的性能浪费

### 四、总结

#### 核心价值

- 直接复制现有对象比重新构建更高效，避免昂贵的初始化操作

- 避免复杂的初始化参数

- 在运行时动态决定创建对象的类型，配置灵活

- 客户端代码不依赖于具体的类，减少耦合

#### 缺点

- 克隆实现较为复杂，需处理循环引用的问题

- 深拷贝时，申请的内存增加，要谨慎管理资源的释放


### 适用场景

- 对象创建成本高，体积大或比较复杂

- 需要大量相似对象

- 避免构造函数参数过多/逻辑复杂的限制

- 需要运行时确定对象类型，可以根据配置动态创建，编译时不确定



