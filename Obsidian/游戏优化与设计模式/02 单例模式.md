
### 零、概念

- **是什么**：一种设计模式，使得我们可以创建一个对象，使其在全局都可以被访问，且该对象在全局唯一

- **解决问题**：我们需要一个全局的“管理器”或者资源存储处，使得其数据可以被全局共享，其方法可以在全局被调用

- **举例**：观察者模式中的全局事件中心就是一个单例

### 一、实现要点

- 私有化构造函数、删除拷贝与赋值：防止外部创建和复制实例

- 静态成员变量：保存唯一实例

- 静态方法提供访问：获取唯一实例

### 二、UML图展示
![500](单例模式UML.png)

### 三、最佳实践

- 在`GetInstance()`中存储一个`static Singleton instance`的静态变量，并返回`instance`

	- 在C++中是推荐且简明的写法

	- 适用于绝大多数情况

- 其他对象进行引用时，最好不要在类中保存一个变量存单例，会增加类体积

	- 在需要用的地方再调用`GetInstance()`即可，语意也清晰

### 四、历史问题

- 对于C++11之前的版本，需要在类中保存`_instance`静态成员指针变量，并在类外初始化

	- 在`GetInstance()`中做判断，用到时再实例化
	
	- 还需添加`Destroy()`方法释放`_instance`
	
- 为了线程安全，还要在`GetInstance()`中加`mutex`锁，一次只放一个线程通过，其他线程需等待通过的线程执行完毕后再接着通过
	
	- 防止`_instance`被重复实例化
	
	- `_mutex`作为静态成员变量，也要在类外初始化

- 但是，线程安全问题只会在初始化时产生，初始化完成后，多线程同时访问`_instance`行为是符合预期的

	- 一种解决办法是双重检查锁定，但实现比较复杂
	
	- 还有一种是`std::one_flag`和`std::call_once`，从语法上使得初始化只会执行一次

### 五、总结：创建单例的几种方式

- 懒汉式（Lazy Initialization），即第一次访问单例时才创建单例 - 线程不安全

- 饿汉式（Eager Initialization），即在第一次访问单例之前才创建单例 - 线程安全

- 懒汉式 + Mutex - 线程安全，C++11 之前

- 懒汉式 + `std::call_once` - 线程安全

- Meyer's Singleton（局部静态变量）- 线程安全，且最简洁和推荐

- 双重检查锁定 - 最复杂，不建议
